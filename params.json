{"name":"Object ","tagline":"","body":"<script>\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-43253811-1', 'soumendas.github.io');\r\n  ga('send', 'pageview');\r\n\r\n</script>\r\n# Object Creation\r\n\r\n### Factory Pattern:\r\n``` javascript\r\nfunction a(){\r\n    var obj = {\r\n        b : \"Hi! \",\r\n        c : \"Bye!\"\r\n    };\r\n    return obj;\r\n}\r\n\r\nvar z = a();                             //i.e z = obj\r\nconsole.log(z.b, z.c);                   // Hi! Bye!\r\n\r\nz.constructor === Object;                // true\r\nz instanceof Object;                    // obvious: every object is instance of Object\r\n\r\nz.constructor === obj;\r\n//ReferenceError: 'obj' is undefined because its defined inside 'a'  \r\n                                  \r\nz instanceof obj;                         \r\n// ReferenceError: 'obj' is undefined because its defined inside 'a'\r\n//The problem now is we can't tell which specific object z belongs to.\r\n```  \r\n###Disadvantage:  \r\nIt becomes difficult to query for the origin specific object. This can be overcomed by Constructor Pattern  \r\n###Constructor Pattern:\r\n``` javascript  \r\nfunction A(){\r\n    this.b = \"Hi! \";\r\n    this.c = \"Bye!\";\r\n    this.show = function(){\r\n    \tconsole.log(z.b,z.c);\r\n\t};\r\n};\r\n\r\nvar z = new A();\r\nz.show();\r\nz instanceof A;           //true\r\nz instanceof Object;      //true\r\nA instanceof Object;      //true\r\n\r\nvar x = new A();\r\nx.show();\r\n```  \r\n###Disadvantage:\r\nHere **z** and **x** both have their own copy of **show()** method as ***this*** is used i.e. it is not shared hence takes up memory. This can be overcomed by Prototype Pattern.\r\n###Prototype Pattern:\r\n``` javascript  \r\nfunction A(){\r\n}\r\nA.prototype = {\r\n    constructor: A,    \r\n    /*Here creating the prototype object overrides the inherited prototype so constructor is made to point to A*/\r\n    b : \"Hi! \",\r\n    c : \"Bye!\",\r\n    d : [\"Hi\",\"there!\"],\r\n    show : function(){\r\n    console.log(this.b,this.c);\r\n    }\r\n}\r\n\r\nvar z = new A();\r\nvar x = new A();\r\nx.d;                  //before change: [\"Hi\",\"there!\"]\r\nz.show();             \r\nz.d.push(\"Soumen\"); \r\nx.d;                  //after change: [\"Hi\",\"there!\",\"Soumen\"]\r\n    \r\n```\r\n###Disadvantage:\r\nHere since prototype is used everything in A is shared among its instances. So changing array **d** through **z** causes **d** to change for all instances. This can be overcomed by using both constructor pattern for individual properties as well as prototype pattern for methods.","google":"UA-43253811-1","note":"Don't delete this file! It's used internally to help with page regeneration."}